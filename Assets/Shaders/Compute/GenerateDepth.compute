// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel GenerateDepth

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
// 0-3, newest to oldest
RWStructuredBuffer<float> KinectDepth0;
RWStructuredBuffer<float> KinectDepth1;
RWStructuredBuffer<float> KinectDepth2;
RWStructuredBuffer<float> KinectDepth3;
float rangeMin;
float rangeMax;
int width;
int height;
float weight;

/*float AvgDepth(RWStructuredBuffer<float> depthData, uint3 id, int width, int height)
{
	float sum = 0;
	int count = 0;

	for(int x = -1; x < 2; x++)
	{
		for (int y = -1; y < 2; y++)
		{
			x = id.x + x;
			y = id.y + y;
			if( x >= 0 && x < width && y >= 0 && y < height)
			{
				sum += depthData[y * width + x];
				count++;
			}
		}
	}

	return count > 0 ? sum / count : 0;
}*/

[numthreads(1, 1, 1)]
void GenerateDepth (uint3 id : SV_DispatchThreadID)  
{
	// NOTE : Smoothing Algorithm adapted from https://www.codeproject.com/Articles/317974/KinectDepthSmoothing
	// Just using the Weighted Moving Average to reduce flicking and smooth transition over 4 frames.
	float darray[4];
	darray[0] = KinectDepth0[id.y * width + id.x]; //AvgDepth(KinectDepth0, id, width, height);
	// If the value is within range, convert to 0-1 depth value then flip, else use the existing texture value as basic hand/head rejection
	darray[0] = (darray[0] > rangeMin && darray[0] <= rangeMax) ? 1.0 - ((darray[0] - rangeMin)/(rangeMax - rangeMin)) : Result[id.xy].x;
	darray[1] = KinectDepth1[id.y * width + id.x]; //AvgDepth(KinectDepth1, id, width, height);
	darray[1] = (darray[1] > rangeMin && darray[1] <= rangeMax) ? 1.0 - ((darray[1] - rangeMin)/(rangeMax - rangeMin)) : Result[id.xy].x;
	darray[2] = KinectDepth2[id.y * width + id.x]; // AvgDepth(KinectDepth2, id, width, height);
	darray[2] = (darray[2] > rangeMin && darray[2] <= rangeMax) ? 1.0 - ((darray[2] - rangeMin)/(rangeMax - rangeMin)) : Result[id.xy].x;
	darray[3] = KinectDepth3[id.y * width + id.x]; // AvgDepth(KinectDepth3, id, width, height);
	darray[3] = (darray[3] > rangeMin && darray[3] <= rangeMax) ? 1.0 - ((darray[3] - rangeMin)/(rangeMax - rangeMin)) : Result[id.xy].x;

	// For each sample that isn't 0, 
	// Add it to the sum multiplied by the count and increase
	// the denominator by the current count.
	int denominator = 0;
	int count = 1;
	float sum = 0;
	for(int i = 3; i >= 0; i--)
	{
		if(darray[i] > 0)
		{
			sum += darray[i] * count;
			denominator += count;
			count++;
		}
	}

	// If we found any non zero pixels
	if(denominator > 0)
	{
		// Moving Average
		float d = (sum / denominator);
		// Blend with weighted existing value.
		d = (d + (Result[id.xy].x * weight)) / (weight + 1);
		Result[id.xy] = float4(d, d, d, 1.0);
	}
	else
	{
		// zero depth
		Result[id.xy] = float4(0, 0, 0, 1);
	}
} 
